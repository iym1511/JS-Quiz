// 멘토링
// 💡 문제 푸는방식
// 각각 배열에서 index가 등수 이고 배열 안의 정수가 학생이다
// 그렇다면 각각의 배열에서 항상 멘토와 멘티가 되는 학생을 찾으시오
// 정답은 [3,1, 3,2, 4,2] 이다. 모든 배열에서 이 세 짝궁은
// 항상 성적이 왼쪽이 더 높고 오른쪽이 낮기 때문에 총 짝은 3명이다.

// 결론
// 1. i와j는 학생을 가리키는 정수이다.
// 2. k는 다음 시험결과로 이동시켜주는 역할이고
//    s는 학생의 순위를 알려준다.
// 3. 학생3과 학생1은 모든배열에서 항상 학생3이 성적이 높다.
// 4. 학생3과 학생2는 모든배열에서 항상 학생3이 성적이 높다.
// 5. 학생4와 학생2는 모든배열에서 항상 학생4가 성적이 높다.

// < i와 j가 순회하는 학생(정수) >
// 1,1 / 1,2 / 1,3 / 1,4
// 2,1 / 2,2 / 2,3 / 2,4
// 3,1 / 3,2 / 3,3 / 3,4
// 4,1 / 4,2 / 4,3 / 4,4

const Sol3 = () => {

  const arr = [[3,4,1,2], [4,3,2,1], [3,1,4,2]];

  const solution = (arr) => {
    let answer = 0;
    let m = arr.length; // 총 시험치른 횟수
    let n = arr[0].length; // 학생 인원

    for(let i = 1; i<=n; i++){
      for(let j = 1; j<=n; j++){
        // 한쌍의 학생 시험별 등수체크가 끝나면 count 초기화
        // (한쌍이 모든시험에서 멘토 멘티가 가능한지 확인을 하기 위함)
        let cnt = 0;
        for(let k = 0; k<m; k++){
          // 하나의 시험 등수를 확인할때마다 초기화
          let pi = 0;
          let pj = 0;
          for(let s = 0; s<n; s++){
            if(arr[k][s] === i) pi=s;
            if(arr[k][s] === j) pj=s;
          }
          // index가 더 작은쪽이 등수가 높기때문에 pj가 커야 cnt 증가 
          // (cnt는 멘토 멘티가 가능해야 ++)
          if(pi < pj) cnt++;
        }
        // 배열 3곳(3개의 시험)에서 다 왼쪽이 성적이 좋아야 멘토 멘티가 되기 때문에 +3 이 되어야 answer++
        if(cnt === m) answer++;

      }
    }

    return answer;
  }

  console.log(solution(arr));

  return (  
    <div>

    </div>
  );
}
 
export default Sol3;